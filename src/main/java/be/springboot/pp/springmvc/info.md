### Q. What is HTTP ?
- application layer protocol
- stands for HyperText Transfer Protocol
- HyperText = Structured-Text + Links
- An HTTP request contains some sort of links/url/path. Like, 'GET /book/anything.html'
- Text present in an HTTP request has distinct components with unique objective.
- stateless protocol: server do not keep any context about client in between requests.

### Q. If HTTP is stateless then how recommendation system works ?
- using cookies/tokens
- It goes as a part of HTTP request and helps server form a unique response tailored for you using info stored in your cookies/tokens

## Components of a Request
- Method: GET, POST, PUT, PATCH, etc.
- URL: Uniform Resource Locator
- Version: 
- Headers: It contains additional information. Like,
  - Content-Type: 
- Body: (Optional)
- request-path:
- request-params:

## Components of a Response
- Status-code:
- Status-message:
- Header:
- Body:

## Servlet
- all these interactions are handled by Server, from now on which will be called Servlet-container.
- Example of HTTP servers (servlet-containers): TomCat, Jetty
- Servlet: anything that says 'let us server'.
- It is entry point of application for taking handover of a request and forwarding it.
- Servlet is an interface with three important methods -
  - `init()`: initialize a servlet with all required dependencies
  - `service()`: accepts a request and forwards it to appropriate handler, gets a response from there and translates it back to an HTTP response and serves back to OS.
  - `destroy()`: servlet is shut down.
- Servlet-containers creates servlets.
- `Process finished with exit code 0` means no server initialized. A process ran and exited.
- In old days, a JAR was generated by `mvn install` which then was deployed
  - this violates containerisation.
  - had a lot of issues -
    - like Java version of server and application can be different.
    - SPOF
    - separate server configuration for each application is not possible  
  - had some benefits as well -
    - multiple application can be run on it.
- Containerisation: everything is bundled in a container, so application and server shares same environment.

## DispatcherServlet
- Tomcat world ends and spring world begins as soon as request enters dispatcher-servlet.
- Servlet passes request to spring-mvc
- the component in spring-mvc which receives the request from servlet is called 'Dispatcher Servlet'
- Dispatcher-servlet forwards request to a particular controller
- Dispatcher-servlet keeps all request-mapping
- this Dispatcher-servlet design pattern is called 'Front Controller'
- Dispatcher-servlet => Interceptor => Controller => Interceptor => Dispatcher-servlet => Tomcat

### code architecture of DispatcherServlet
- it maintains a list of handler-mapping (controller methods mapped to a route)
- maintains a list of handler-adapters
- every method we write is internally converted to an object of `Method` by Java.
- every `Method` written in `Controller` file is converted into an object of `HandlerMethod`
- `HandlerMethod` is a class present in spring-mvc
- `HandlerMethod` is a wrapper of `Method` object against which a route mapping is kept
- every method annotated with `@RequestMapping`, once converted into `Method` object by JVM is then wrapped into `HandlerMethod` by Spring
- In dispatcher-servlet world, the method once wrapped into `HandlerMethod` is called a `handler`
- Dispatcher-servlet has a chain of handler-execution called `HandlerExecutionChain`, at the end of which the last handler is our method written in controller.
- all other remaining links of chain are the `preHandle()/postHandle()` methods of interceptors registered.
- as soon as a request is handed over to dispatcher-servlet, `preHandle()` of all interceptors are executed on it. Then controller method is executed by handler-adapter which gives a response. Then `postHandle()` of interceptors in reverse order of registry is executed. Finally, the response is handed back to servlet.
- a handler-adapter executes/handles a handler because `handler` is of type `Object`
- dispatcher-servlet first finds which handler-adapter can execute given handler, then once `preHandle()` interceptors are executed, executes the handler using handler-adapter.

### important attributes of DispatcherServlet
- `MultipartResolver` resolves requests containing some chunks of a huge file sent in multiple parts in separate requests.
- `LocaleResolver` resolves the locality of the request so that timezone, language and characters interpretation can be done.
- `List<HandlerMapping>` returns a `HandlerExecutionChain` after resolving the handler
- `HandlerExecutionChain` maintains order of interceptor execution
- `HandlerExecutionChain` contains methods to execute interceptors only, not for handler
- handler is of `Object` type, it has no capabilities, nothing can be done on it to get a response
- `HandlerAdapter` adapts the handler to a specific type so that request can be executed and response can be generated.
- we go to all the adapters one by one and check which one can execute the handler using `getHandlerAdapter()`
- once we find a `HandlerAdapter`, we pass handler to adapters `handle()` method

## Interceptor
- it is an interface called HandlerInterceptor
- `preHandle()` is invoked before request is handed over to controller
- `postHandle()` is invoked when Controller hands over response to Interceptor
- there purpose is to take care of cross-cutting concerns
- cross-cutting concerns: concerns not related to regular algorithms/business-logic
- concerns related to logging request, measure API latency, adding missing header, processing header.
- concerns which are associated with incoming request, before we get into processing business logic on it.
- to register an Interceptor in MVC flow, we use `WebMvcConfigurer` interface.
- When `http://localhost:8080/simple/greet/samar` request came, order was -
  - `SimpleInterceptor: preHandle` org.apache.catalina.connector.RequestFacade@510cb46d
  - `SecondInterceptor: preHandle` org.apache.catalina.connector.RequestFacade@510cb46d
  - `Received request with path variable 'name' samar`
  - `SecondInterceptor: postHandle` org.apache.catalina.connector.RequestFacade@510cb46d
  - `SimpleInterceptor: postHandle` org.apache.catalina.connector.RequestFacade@510cb46d
- After adding `/result` path in `.excludePathPatterns()` for `SecondInterceptor` then once `http://localhost:8080/simple/result` request came, order was -
  - `SimpleInterceptor: preHandle` org.apache.catalina.connector.RequestFacade@6cba67d9
  - `Received result request`
  - `SimpleInterceptor: postHandle` org.apache.catalina.connector.RequestFacade@6cba67d9

### Q. Difference between @Controller and @RestController ?
- @RestController = @Controller + @ResponseBody

### Request-param vs path-variable
- Request-param may have optional fields but path-variable need to be filled mandatory in the URL.
- URL should be highly readable.
- large values in params is acceptable but not in path.

### Note:
- While dealing with Object serialization and deserialization of web request is an important aspect of web framework.
- purpose of framework is to abstract out the mundane boiler-plate code
- when exception is thrown we need to translate it to an error code and return suitable response, `DispatcherServlet` has `HandlerExceptionResolver` for this purpose.

## flow of Spring
- Servlet-container (Tomcat) listens to a webSocket and receives a request from kernel (OS)
- which then is forward to spring-mvc
- spring-mvc class which accepts the request from servlet-container is `DispatcherServlet`
- `DispatcherServlet` is responsible for dispatching request to the correct controller via request-mapping routes.
